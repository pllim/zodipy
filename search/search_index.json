{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>ZodiPy is an Astropy affiliated package, which simulates the zodiacal light in intensity that an arbitrary solar system observer is predicted to see given an interplanetary dust model and a scanning strategy, either in the form of timestreams or HEALPix maps. </p>"},{"location":"#a-simple-example","title":"A simple example","text":"<pre><code>import astropy.units as u\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\n\nmodel = Zodipy(\"dirbe\")\n\nemission = model.get_emission_ang(\n    25 * u.micron,\n    theta=[10, 10.1, 10.2] * u.deg,\n    phi=[90, 89, 88] * u.deg,\n    obs_time=Time(\"2022-01-01 12:00:00\"),\n    obs=\"earth\",\n    lonlat=True,\n)\n\nprint(emission)\n#&gt; [15.53095493 15.52883577 15.53121942] MJy / sr\n</code></pre> <p>What's going on here:</p> <ul> <li>We start by initializing the <code>Zodipy</code> class, which is our interface, where we specify that we want to use the DIRBE interplanetary dust model.</li> <li>We use the <code>get_emission_ang</code> method which is a method to simulate emission from angular sky coordinates (see the reference for other available simulation methods).</li> <li>The first argument to the <code>get_emission_ang</code> method, <code>25 * u.micron</code>, specifies the wavelength of the simulated observation. Note that we use Astropy units for many of the input arguments.</li> <li><code>theta</code> and <code>phi</code> represent the pointing of the observation (co-latitude and longitude, following the healpy convention). In this example we observe three sky coordinates.</li> <li><code>obs_time</code> represents the time of observation, which we need to compute the position of the observer and all other required solar system bodies.</li> <li><code>obs</code> represents the observer, and must be an solar system observer supported by the Astropy ephemeris used internally. If we wish to be more specific about the observer position, we can use the <code>obs_pos</code> keyword instead of <code>obs</code>, which takes in a heliocentric cartesian position in units of AU.</li> <li>Finally, <code>lonlat</code> is a boolean which converts the convention of <code>theta</code> and <code>phi</code> from co-latitude and longitude to longitude and latitude.</li> </ul> <p>For more information on using ZodiPy, see the usage section.</p>"},{"location":"install/","title":"Install","text":"<p>Installing ZodiPy is as simple as:</p> <pre><code>pip install zodipy\n</code></pre> <p>Note</p> <p>ZodiPy supports python versions &gt;=3.8.</p>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>ZodiPy has the following dependencies (these are automatically downloaded alongside ZodiPy):</p> <ul> <li>numpy</li> <li>astropy (&gt;= 5.0.1)</li> <li>healpy</li> <li>jplehem</li> </ul>"},{"location":"introduction/","title":"Introduction","text":"<p>ZodiPy is an open source Python tool for simulating the zodiacal emission that a solar system observer is predicted to see given an interplanetary dust model. We attempts to make zodiacal emission simulations more accessible by providing the community with a simple interface to existing models. For other zodiacal emission tools, see Zodiacal Light Models on LAMBDA. All contributions are most welcome.</p>"},{"location":"introduction/#interplanetary-dust-models","title":"Interplanetary Dust Models","text":"<p>ZodiPy supports the following interplanetary dust models:</p> <p>1.25-240 \\(\\boldsymbol{\\mu}\\)m</p> <ul> <li>DIRBE (Kelsall et al. 1998)</li> <li>RRM (experimental) (Rowan-Robinson and May 2013)</li> </ul> <p>100-857 GHz</p> <ul> <li>Planck 2013 (Planck Collaboration et al. 2014)</li> <li>Planck 2015 (Planck Collaboration et al. 2016)</li> <li>Planck 2018 (Planck Collaboration et al. 2020)</li> <li>Odegard (Odegard et al. 2019)</li> </ul> <p>Info</p> <p>The Planck and Odegard models extend the DIRBE interplanetary dust model to CMB frequencies by fitting the blackbody emissivity of the dust in the respective DIRBE interplanetary dust components to Planck HFI data. The distribution of the interplanetary dust is exactly the same as in the DIRBE model.</p> <p>If you see a missing model, please feel free to contact us by opening an issue on GitHub. </p>"},{"location":"introduction/#scientific-paper","title":"Scientific Paper","text":"<p>For an overview of the modeling approach used in ZodiPy and other information regarding zodiacal emission and interplanetary dust modeling we refer to the scientific paper on ZodiPy:</p> <ul> <li>Cosmoglobe: Simulating zodiacal emission with ZodiPy</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#zodipy.zodipy.Zodipy","title":"<code>Zodipy</code>","text":"<p>Interface for simulating zodiacal emission.</p> <p>This class provides methods for simulating zodiacal emission given observer pointing either in sky angles or through HEALPix pixels.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Name of the interplanetary dust model to use in the simulations. Defaults to DIRBE.</p> <code>'dirbe'</code> <code>gauss_quad_degree</code> <code>int</code> <p>Order of the Gaussian-Legendre quadrature used to evaluate the line-of-sight integral in the simulations. Default is 50 points.</p> <code>50</code> <code>interp_kind</code> <code>str</code> <p>Interpolation kind used to interpolate relevant model parameters. Defaults to 'linear'. For more information on available interpolation methods, please visit the Scipy documentation.</p> <code>'linear'</code> <code>extrapolate</code> <code>bool</code> <p>If <code>True</code> all spectral quantities in the selected model are extrapolated to the requested frequencies or wavelengths. If <code>False</code>, an exception is raised on requested frequencies/wavelengths outside of the valid model range. Default is <code>False</code>.</p> <code>False</code> <code>ephemeris</code> <code>str</code> <p>Ephemeris used to compute the positions of the observer and the Earth. Defaults to 'de432s', which requires downloading (and caching) a ~10MB file. For more information on available ephemeridis, please visit the Astropy documentation</p> <code>'de432s'</code> <code>solar_cut</code> <code>Quantity[deg]</code> <p>Cutoff angle from the sun in degrees. The emission for all the pointing with angular distance between the sun smaller than <code>solar_cutoff</code> are masked. Defaults to <code>None</code>.</p> <code>None</code> <code>solar_cut_fill_value</code> <code>float</code> <p>Fill value for pixels masked with <code>solar_cut</code>. Defaults to <code>np.nan</code>.</p> <code>nan</code> <code>n_proc</code> <code>int</code> <p>Number of cores to use. If <code>n_proc</code> is greater than 1, the line-of-sight integrals are parallelized using the <code>multiprocessing</code> module. Defaults to 1.</p> <code>1</code> Source code in <code>zodipy/zodipy.py</code> <pre><code>class Zodipy:\n\"\"\"Interface for simulating zodiacal emission.\n\n    This class provides methods for simulating zodiacal emission given observer pointing\n    either in sky angles or through HEALPix pixels.\n\n    Args:\n        model (str): Name of the interplanetary dust model to use in the simulations.\n            Defaults to DIRBE.\n        gauss_quad_degree (int): Order of the Gaussian-Legendre quadrature used to evaluate\n            the line-of-sight integral in the simulations. Default is 50 points.\n        interp_kind (str): Interpolation kind used to interpolate relevant model parameters.\n            Defaults to 'linear'. For more information on available interpolation methods,\n            please visit the [Scipy documentation](\n            https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html).\n        extrapolate (bool): If `True` all spectral quantities in the selected model are\n            extrapolated to the requested frequencies or wavelengths. If `False`, an\n            exception is raised on requested frequencies/wavelengths outside of the\n            valid model range. Default is `False`.\n        ephemeris (str): Ephemeris used to compute the positions of the observer and the\n            Earth. Defaults to 'de432s', which requires downloading (and caching) a ~10MB\n            file. For more information on available ephemeridis, please visit the [Astropy\n            documentation](https://docs.astropy.org/en/stable/coordinates/solarsystem.html)\n        solar_cut (u.Quantity[u.deg]): Cutoff angle from the sun in degrees. The emission\n            for all the pointing with angular distance between the sun smaller than\n            `solar_cutoff` are masked. Defaults to `None`.\n        solar_cut_fill_value (float): Fill value for pixels masked with `solar_cut`.\n            Defaults to `np.nan`.\n        n_proc (int): Number of cores to use. If `n_proc` is greater than 1, the line-of-sight\n            integrals are parallelized using the `multiprocessing` module. Defaults to 1.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        model: str = \"dirbe\",\n        gauss_quad_degree: int = 50,\n        extrapolate: bool = False,\n        interp_kind: str = \"linear\",\n        ephemeris: str = \"de432s\",\n        solar_cut: u.Quantity[u.deg] | None = None,\n        solar_cut_fill_value: float = np.nan,\n        n_proc: int = 1,\n    ) -&gt; None:\n        self.model = model\n        self.gauss_quad_degree = gauss_quad_degree\n        self.extrapolate = extrapolate\n        self.interp_kind = interp_kind\n        self.ephemeris = ephemeris\n        self.solar_cut = solar_cut.to(u.rad) if solar_cut is not None else solar_cut\n        self.solar_cut_fill_value = solar_cut_fill_value\n        self.n_proc = n_proc\n\n        self._interpolator = partial(\n            interp1d,\n            kind=self.interp_kind,\n            fill_value=\"extrapolate\" if self.extrapolate else np.nan,\n        )\n        self._ipd_model = model_registry.get_model(model)\n        self._gauss_points_and_weights = np.polynomial.legendre.leggauss(gauss_quad_degree)\n\n    @property\n    def supported_observers(self) -&gt; list[str]:\n\"\"\"Return a list of available observers given an ephemeris.\"\"\"\n        return [*list(solar_system_ephemeris.bodies), \"semb-l2\"]\n\n    def get_parameters(self) -&gt; ParameterDict:\n\"\"\"Return a dictionary containing the interplanetary dust model parameters.\"\"\"\n        return self._ipd_model.to_dict()\n\n    def update_parameters(self, parameters: ParameterDict) -&gt; None:\n\"\"\"Update the interplanetary dust model parameters.\n\n        Args:\n            parameters: Dictionary of parameters to update. The keys must be the names\n                of the parameters as defined in the model. To get the parameters dict\n                of an existing model, use `Zodipy(\"dirbe\").get_parameters()`.\n\n        \"\"\"\n        _dict = parameters.copy()\n        _dict[\"comps\"] = {}\n        for key, value in parameters.items():\n            if key == \"comps\":\n                for comp_key, comp_value in value.items():\n                    _dict[\"comps\"][ComponentLabel(comp_key)] = type(\n                        self._ipd_model.comps[ComponentLabel(comp_key)]\n                    )(**comp_value)\n            elif isinstance(value, dict):\n                _dict[key] = {ComponentLabel(k): v for k, v in value.items()}\n\n        self._ipd_model = self._ipd_model.__class__(**_dict)\n\n    def get_emission_ang(\n        self,\n        freq: FrequencyOrWavelength,\n        theta: SkyAngles,\n        phi: SkyAngles,\n        obs_time: Time,\n        obs: str = \"earth\",\n        obs_pos: u.Quantity[u.AU] | None = None,\n        weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n        lonlat: bool = False,\n        return_comps: bool = False,\n        coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n    ) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated zodiacal emission given angles on the sky.\n\n        The pointing, for which to compute the emission, is specified in form of angles on\n        the sky given by `theta` and `phi`.\n\n        Args:\n            freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n                a bandpass over which to evaluate the zodiacal emission. The frequencies\n                must be strictly increasing.\n            theta: Angular co-latitude coordinate of a point, or a sequence of points, on\n                the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either\n                radians or degrees.\n            phi: Angular longitude coordinate of a point, or a sequence of points, on the\n                celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either\n                radians or degrees.\n            obs_time: Time of observation.\n            obs: Name of the Solar System observer. A list of all support observers (for a\n                given ephemeridis) is specified in `supported_observers` attribute of the\n                `Zodipy` instance. Defaults to 'earth'.\n            obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n                Overrides the `obs` argument. Default is None.\n            weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n                are assumed to be given in spectral radiance units (Jy/sr).\n            lonlat: If True, input angles (`theta`, `phi`) are assumed to be longitude and\n                latitude, otherwise, they are co-latitude and longitude.\n            return_comps: If True, the emission is returned component-wise. Defaults to False.\n            coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n                coordinates) by default.\n\n        Returns:\n            emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n        \"\"\"\n        theta, phi = get_validated_ang(theta=theta, phi=phi, lonlat=lonlat)\n\n        unique_angles, indicies = np.unique(np.asarray([theta, phi]), return_inverse=True, axis=1)\n        unit_vectors = get_unit_vectors_from_ang(\n            coord_in=coord_in,\n            theta=unique_angles[0],\n            phi=unique_angles[1],\n            lonlat=lonlat,\n        )\n\n        return self._compute_emission(\n            freq=freq,\n            weights=weights,\n            obs=obs,\n            obs_time=obs_time,\n            obs_pos=obs_pos,\n            unit_vectors=unit_vectors,\n            indicies=indicies,\n            return_comps=return_comps,\n        )\n\n    def get_emission_pix(\n        self,\n        freq: FrequencyOrWavelength,\n        pixels: Pixels,\n        nside: int,\n        obs_time: Time,\n        obs: str = \"earth\",\n        obs_pos: u.Quantity[u.AU] | None = None,\n        weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n        return_comps: bool = False,\n        coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n    ) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated zodiacal emission given pixel numbers.\n\n        The pixel numbers represent the pixel indicies on a HEALPix grid with resolution\n        given by `nside`.\n\n        Args:\n            freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n                a bandpass over which to evaluate the zodiacal emission. The frequencies\n                must be strictly increasing.\n            pixels: HEALPix pixel indicies representing points on the celestial sphere.\n            nside: HEALPix resolution parameter of the pixels and the binned map.\n            obs_time: Time of observation.\n            obs: Name of the Solar System observer. A list of all support observers (for a\n                given ephemeridis) is specified in `supported_observers` attribute of the\n                `Zodipy` instance. Defaults to 'earth'.\n            obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n                Overrides the `obs` argument. Default is None.\n            weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n                are assumed to be given in spectral radiance units (Jy/sr).\n            return_comps: If True, the emission is returned component-wise. Defaults to False.\n            coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n                coordinates) by default.\n\n        Returns:\n            emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n        \"\"\"\n        pixels = get_validated_pix(pixels=pixels, nside=nside)\n\n        unique_pixels, indicies = np.unique(pixels, return_inverse=True)\n        unit_vectors = get_unit_vectors_from_pixels(\n            coord_in=coord_in,\n            pixels=unique_pixels,\n            nside=nside,\n        )\n\n        return self._compute_emission(\n            freq=freq,\n            weights=weights,\n            obs=obs,\n            obs_time=obs_time,\n            obs_pos=obs_pos,\n            unit_vectors=unit_vectors,\n            indicies=indicies,\n            pixels=unique_pixels,\n            nside=nside,\n            return_comps=return_comps,\n        )\n\n    def get_binned_emission_ang(\n        self,\n        freq: FrequencyOrWavelength,\n        theta: SkyAngles,\n        phi: SkyAngles,\n        nside: int,\n        obs_time: Time,\n        obs: str = \"earth\",\n        obs_pos: u.Quantity[u.AU] | None = None,\n        weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n        lonlat: bool = False,\n        return_comps: bool = False,\n        coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n    ) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated binned zodiacal emission given angles on the sky.\n\n        The pointing, for which to compute the emission, is specified in form of angles on\n        the sky given by `theta` and `phi`. The emission is binned to a HEALPix map with\n        resolution given by `nside`.\n\n        Args:\n            freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n                a bandpass over which to evaluate the zodiacal emission. The frequencies\n                must be strictly increasing.\n            theta: Angular co-latitude coordinate of a point, or a sequence of points, on\n                the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either\n                radians or degrees.\n            phi: Angular longitude coordinate of a point, or a sequence of points, on the\n                celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either\n                radians or degrees.\n            nside: HEALPix resolution parameter of the binned map.\n            obs_time: Time of observation.\n            obs: Name of the Solar System observer. A list of all support observers (for a\n                given ephemeridis) is specified in `supported_observers` attribute of the\n                `Zodipy` instance. Defaults to 'earth'.\n            obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n                Overrides the `obs` argument. Default is None.\n            weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n                are assumed to be given in spectral radiance units (Jy/sr).\n            lonlat: If True, input angles `theta`, `phi` are assumed to be longitude and\n                latitude, otherwise, they are co-latitude and longitude.\n            return_comps: If True, the emission is returned component-wise. Defaults to False.\n            coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n                coordinates) by default.\n\n        Returns:\n            emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n        \"\"\"\n        theta, phi = get_validated_ang(theta=theta, phi=phi, lonlat=lonlat)\n\n        unique_angles, counts = np.unique(np.asarray([theta, phi]), return_counts=True, axis=1)\n        unique_pixels = hp.ang2pix(nside, *unique_angles, lonlat=lonlat)\n        unit_vectors = get_unit_vectors_from_ang(\n            coord_in=coord_in,\n            theta=unique_angles[0],\n            phi=unique_angles[1],\n            lonlat=lonlat,\n        )\n\n        return self._compute_emission(\n            freq=freq,\n            weights=weights,\n            obs=obs,\n            obs_time=obs_time,\n            obs_pos=obs_pos,\n            unit_vectors=unit_vectors,\n            indicies=counts,\n            binned=True,\n            pixels=unique_pixels,\n            nside=nside,\n            return_comps=return_comps,\n        )\n\n    def get_binned_emission_pix(\n        self,\n        freq: FrequencyOrWavelength,\n        pixels: Pixels,\n        nside: int,\n        obs_time: Time,\n        obs: str = \"earth\",\n        obs_pos: u.Quantity[u.AU] | None = None,\n        weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n        return_comps: bool = False,\n        coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n    ) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated binned zodiacal Emission given pixel numbers.\n\n        The pixel numbers represent the pixel indicies on a HEALPix grid with resolution\n        given by `nside`. The emission is binned to a HEALPix map with resolution given by\n        `nside`.\n\n        Args:\n            freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n                a bandpass over which to evaluate the zodiacal emission. The frequencies\n                must be strictly increasing.\n            pixels: HEALPix pixel indicies representing points on the celestial sphere.\n            nside: HEALPix resolution parameter of the pixels and the binned map.\n            obs_time: Time of observation.\n            obs: Name of the Solar System observer. A list of all support observers (for a\n                given ephemeridis) is specified in `supported_observers` attribute of the\n                `Zodipy` instance. Defaults to 'earth'.\n            obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n                Overrides the `obs` argument. Default is None.\n            weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n                are assumed to be given in spectral radiance units (Jy/sr).\n            return_comps: If True, the emission is returned component-wise. Defaults to False.\n            coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n                coordinates) by default.\n\n        Returns:\n            emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n        \"\"\"\n        pixels = get_validated_pix(pixels=pixels, nside=nside)\n\n        unique_pixels, counts = np.unique(pixels, return_counts=True)\n        unit_vectors = get_unit_vectors_from_pixels(\n            coord_in=coord_in,\n            pixels=unique_pixels,\n            nside=nside,\n        )\n\n        return self._compute_emission(\n            freq=freq,\n            weights=weights,\n            obs=obs,\n            obs_time=obs_time,\n            obs_pos=obs_pos,\n            unit_vectors=unit_vectors,\n            indicies=counts,\n            binned=True,\n            pixels=unique_pixels,\n            nside=nside,\n            return_comps=return_comps,\n        )\n\n    def _compute_emission(\n        self,\n        freq: FrequencyOrWavelength,\n        weights: Sequence[float] | npt.NDArray[np.floating] | None,\n        obs: str,\n        obs_time: Time,\n        unit_vectors: npt.NDArray[np.float64],\n        indicies: npt.NDArray[np.int64],\n        binned: bool = False,\n        obs_pos: u.Quantity[u.AU] | None = None,\n        pixels: npt.NDArray[np.int64] | None = None,\n        nside: int | None = None,\n        return_comps: bool = False,\n    ) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Compute the component-wise zodiacal emission.\"\"\"\n        bandpass = validate_and_get_bandpass(\n            freq=freq,\n            weights=weights,\n            model=self._ipd_model,\n            extrapolate=self.extrapolate,\n        )\n\n        # Get model parameters, some of which have been interpolated to the given\n        # frequency or bandpass.\n        source_parameters = SOURCE_PARAMS_MAPPING[type(self._ipd_model)](\n            bandpass, self._ipd_model, self._interpolator\n        )\n\n        observer_position, earth_position = get_obs_and_earth_positions(\n            obs=obs, obs_time=obs_time, obs_pos=obs_pos\n        )\n\n        # Get the integration limits for each zodiacal component (which may be\n        # different or the same depending on the model) along all line of sights.\n        start, stop = get_line_of_sight_start_and_stop_distances(\n            components=self._ipd_model.comps.keys(),\n            unit_vectors=unit_vectors,\n            obs_pos=observer_position,\n        )\n\n        density_partials = construct_density_partials_comps(\n            comps=self._ipd_model.comps,\n            dynamic_params={\"X_earth\": earth_position},\n        )\n\n        # Make table of pre-computed bandpass integrated blackbody emission.\n        bandpass_interpolatation_table = get_bandpass_interpolation_table(bandpass)\n\n        common_integrand = partial(\n            EMISSION_MAPPING[type(self._ipd_model)],\n            X_obs=observer_position,\n            bp_interpolation_table=bandpass_interpolatation_table,\n            **source_parameters[\"common\"],\n        )\n\n        if self.n_proc &gt; 1:\n            unit_vector_chunks = np.array_split(unit_vectors, self.n_proc, axis=-1)\n            integrated_comp_emission = np.zeros((len(self._ipd_model.comps), unit_vectors.shape[1]))\n            with multiprocessing.get_context(SYS_PROC_START_METHOD).Pool(\n                processes=self.n_proc\n            ) as pool:\n                for idx, comp_label in enumerate(self._ipd_model.comps.keys()):\n                    stop_chunks = np.array_split(stop[comp_label], self.n_proc, axis=-1)\n                    if start[comp_label].size == 1:\n                        start_chunks = [start[comp_label]] * self.n_proc\n                    else:\n                        start_chunks = np.array_split(start[comp_label], self.n_proc, axis=-1)\n                    comp_integrands = [\n                        partial(\n                            common_integrand,\n                            u_los=np.expand_dims(unit_vectors, axis=-1),\n                            start=np.expand_dims(start, axis=-1),\n                            stop=np.expand_dims(stop, axis=-1),\n                            get_density_function=density_partials[comp_label],\n                            **source_parameters[comp_label],\n                        )\n                        for unit_vectors, start, stop in zip(\n                            unit_vector_chunks, start_chunks, stop_chunks\n                        )\n                    ]\n\n                    proc_chunks = [\n                        pool.apply_async(\n                            _integrate_gauss_quad,\n                            args=(comp_integrand, *self._gauss_points_and_weights),\n                        )\n                        for comp_integrand in comp_integrands\n                    ]\n\n                    integrated_comp_emission[idx] += (\n                        np.concatenate([result.get() for result in proc_chunks])\n                        * 0.5\n                        * (stop[comp_label] - start[comp_label])\n                    )\n\n        else:\n            integrated_comp_emission = np.zeros((len(self._ipd_model.comps), unit_vectors.shape[1]))\n            unit_vectors_expanded = np.expand_dims(unit_vectors, axis=-1)\n\n            for idx, comp_label in enumerate(self._ipd_model.comps.keys()):\n                comp_integrand = partial(\n                    common_integrand,\n                    u_los=unit_vectors_expanded,\n                    start=np.expand_dims(start[comp_label], axis=-1),\n                    stop=np.expand_dims(stop[comp_label], axis=-1),\n                    get_density_function=density_partials[comp_label],\n                    **source_parameters[comp_label],\n                )\n\n                integrated_comp_emission[idx] = (\n                    _integrate_gauss_quad(comp_integrand, *self._gauss_points_and_weights)\n                    * 0.5\n                    * (stop[comp_label] - start[comp_label])\n                )\n\n        emission = np.zeros(\n            (\n                len(self._ipd_model.comps),\n                hp.nside2npix(nside) if binned else indicies.size,\n            )\n        )\n        if binned:\n            emission[:, pixels] = integrated_comp_emission\n        else:\n            emission = integrated_comp_emission[:, indicies]\n\n        if self.solar_cut is not None:\n            ang_dist = hp.rotator.angdist(-observer_position.flatten(), unit_vectors)\n            solar_mask = ang_dist &lt; self.solar_cut.value\n            if binned and pixels is not None:\n                emission[:, pixels[solar_mask]] = self.solar_cut_fill_value\n            else:\n                emission[:, solar_mask[indicies]] = self.solar_cut_fill_value\n\n        emission = (emission &lt;&lt; SPECIFIC_INTENSITY_UNITS).to(u.MJy / u.sr)\n\n        return emission if return_comps else emission.sum(axis=0)\n\n    def __repr__(self) -&gt; str:\n        repr_str = f\"{self.__class__.__name__}(\"\n        for attribute_name, attribute in self.__dict__.items():\n            if attribute_name.startswith(\"_\"):\n                continue\n            repr_str += f\"{attribute_name}={attribute!r}, \"\n\n        return repr_str[:-2] + \")\"\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.supported_observers","title":"<code>supported_observers: list[str]</code>  <code>property</code>","text":"<p>Return a list of available observers given an ephemeris.</p>"},{"location":"reference/#zodipy.zodipy.Zodipy.get_binned_emission_ang","title":"<code>get_binned_emission_ang(freq, theta, phi, nside, obs_time, obs='earth', obs_pos=None, weights=None, lonlat=False, return_comps=False, coord_in='E')</code>","text":"<p>Return the simulated binned zodiacal emission given angles on the sky.</p> <p>The pointing, for which to compute the emission, is specified in form of angles on the sky given by <code>theta</code> and <code>phi</code>. The emission is binned to a HEALPix map with resolution given by <code>nside</code>.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>FrequencyOrWavelength</code> <p>Delta frequency/wavelength or a sequence of frequencies corresponding to a bandpass over which to evaluate the zodiacal emission. The frequencies must be strictly increasing.</p> required <code>theta</code> <code>SkyAngles</code> <p>Angular co-latitude coordinate of a point, or a sequence of points, on the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either radians or degrees.</p> required <code>phi</code> <code>SkyAngles</code> <p>Angular longitude coordinate of a point, or a sequence of points, on the celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either radians or degrees.</p> required <code>nside</code> <code>int</code> <p>HEALPix resolution parameter of the binned map.</p> required <code>obs_time</code> <code>Time</code> <p>Time of observation.</p> required <code>obs</code> <code>str</code> <p>Name of the Solar System observer. A list of all support observers (for a given ephemeridis) is specified in <code>supported_observers</code> attribute of the <code>Zodipy</code> instance. Defaults to 'earth'.</p> <code>'earth'</code> <code>obs_pos</code> <code>Quantity[AU] | None</code> <p>The heliocentric ecliptic cartesian position of the observer in AU. Overrides the <code>obs</code> argument. Default is None.</p> <code>None</code> <code>weights</code> <code>Sequence[float] | NDArray[floating] | None</code> <p>Bandpass weights corresponding the the frequencies in <code>freq</code>. The weights are assumed to be given in spectral radiance units (Jy/sr).</p> <code>None</code> <code>lonlat</code> <code>bool</code> <p>If True, input angles <code>theta</code>, <code>phi</code> are assumed to be longitude and latitude, otherwise, they are co-latitude and longitude.</p> <code>False</code> <code>return_comps</code> <code>bool</code> <p>If True, the emission is returned component-wise. Defaults to False.</p> <code>False</code> <code>coord_in</code> <code>Literal['E', 'G', 'C']</code> <p>Coordinate frame of the input pointing. Assumes 'E' (ecliptic coordinates) by default.</p> <code>'E'</code> <p>Returns:</p> Name Type Description <code>emission</code> <code>Quantity[MJy / sr]</code> <p>Simulated zodiacal emission in units of 'MJy/sr'.</p> Source code in <code>zodipy/zodipy.py</code> <pre><code>def get_binned_emission_ang(\n    self,\n    freq: FrequencyOrWavelength,\n    theta: SkyAngles,\n    phi: SkyAngles,\n    nside: int,\n    obs_time: Time,\n    obs: str = \"earth\",\n    obs_pos: u.Quantity[u.AU] | None = None,\n    weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n    lonlat: bool = False,\n    return_comps: bool = False,\n    coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated binned zodiacal emission given angles on the sky.\n\n    The pointing, for which to compute the emission, is specified in form of angles on\n    the sky given by `theta` and `phi`. The emission is binned to a HEALPix map with\n    resolution given by `nside`.\n\n    Args:\n        freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n            a bandpass over which to evaluate the zodiacal emission. The frequencies\n            must be strictly increasing.\n        theta: Angular co-latitude coordinate of a point, or a sequence of points, on\n            the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either\n            radians or degrees.\n        phi: Angular longitude coordinate of a point, or a sequence of points, on the\n            celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either\n            radians or degrees.\n        nside: HEALPix resolution parameter of the binned map.\n        obs_time: Time of observation.\n        obs: Name of the Solar System observer. A list of all support observers (for a\n            given ephemeridis) is specified in `supported_observers` attribute of the\n            `Zodipy` instance. Defaults to 'earth'.\n        obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n            Overrides the `obs` argument. Default is None.\n        weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n            are assumed to be given in spectral radiance units (Jy/sr).\n        lonlat: If True, input angles `theta`, `phi` are assumed to be longitude and\n            latitude, otherwise, they are co-latitude and longitude.\n        return_comps: If True, the emission is returned component-wise. Defaults to False.\n        coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n            coordinates) by default.\n\n    Returns:\n        emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n    \"\"\"\n    theta, phi = get_validated_ang(theta=theta, phi=phi, lonlat=lonlat)\n\n    unique_angles, counts = np.unique(np.asarray([theta, phi]), return_counts=True, axis=1)\n    unique_pixels = hp.ang2pix(nside, *unique_angles, lonlat=lonlat)\n    unit_vectors = get_unit_vectors_from_ang(\n        coord_in=coord_in,\n        theta=unique_angles[0],\n        phi=unique_angles[1],\n        lonlat=lonlat,\n    )\n\n    return self._compute_emission(\n        freq=freq,\n        weights=weights,\n        obs=obs,\n        obs_time=obs_time,\n        obs_pos=obs_pos,\n        unit_vectors=unit_vectors,\n        indicies=counts,\n        binned=True,\n        pixels=unique_pixels,\n        nside=nside,\n        return_comps=return_comps,\n    )\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.get_binned_emission_pix","title":"<code>get_binned_emission_pix(freq, pixels, nside, obs_time, obs='earth', obs_pos=None, weights=None, return_comps=False, coord_in='E')</code>","text":"<p>Return the simulated binned zodiacal Emission given pixel numbers.</p> <p>The pixel numbers represent the pixel indicies on a HEALPix grid with resolution given by <code>nside</code>. The emission is binned to a HEALPix map with resolution given by <code>nside</code>.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>FrequencyOrWavelength</code> <p>Delta frequency/wavelength or a sequence of frequencies corresponding to a bandpass over which to evaluate the zodiacal emission. The frequencies must be strictly increasing.</p> required <code>pixels</code> <code>Pixels</code> <p>HEALPix pixel indicies representing points on the celestial sphere.</p> required <code>nside</code> <code>int</code> <p>HEALPix resolution parameter of the pixels and the binned map.</p> required <code>obs_time</code> <code>Time</code> <p>Time of observation.</p> required <code>obs</code> <code>str</code> <p>Name of the Solar System observer. A list of all support observers (for a given ephemeridis) is specified in <code>supported_observers</code> attribute of the <code>Zodipy</code> instance. Defaults to 'earth'.</p> <code>'earth'</code> <code>obs_pos</code> <code>Quantity[AU] | None</code> <p>The heliocentric ecliptic cartesian position of the observer in AU. Overrides the <code>obs</code> argument. Default is None.</p> <code>None</code> <code>weights</code> <code>Sequence[float] | NDArray[floating] | None</code> <p>Bandpass weights corresponding the the frequencies in <code>freq</code>. The weights are assumed to be given in spectral radiance units (Jy/sr).</p> <code>None</code> <code>return_comps</code> <code>bool</code> <p>If True, the emission is returned component-wise. Defaults to False.</p> <code>False</code> <code>coord_in</code> <code>Literal['E', 'G', 'C']</code> <p>Coordinate frame of the input pointing. Assumes 'E' (ecliptic coordinates) by default.</p> <code>'E'</code> <p>Returns:</p> Name Type Description <code>emission</code> <code>Quantity[MJy / sr]</code> <p>Simulated zodiacal emission in units of 'MJy/sr'.</p> Source code in <code>zodipy/zodipy.py</code> <pre><code>def get_binned_emission_pix(\n    self,\n    freq: FrequencyOrWavelength,\n    pixels: Pixels,\n    nside: int,\n    obs_time: Time,\n    obs: str = \"earth\",\n    obs_pos: u.Quantity[u.AU] | None = None,\n    weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n    return_comps: bool = False,\n    coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated binned zodiacal Emission given pixel numbers.\n\n    The pixel numbers represent the pixel indicies on a HEALPix grid with resolution\n    given by `nside`. The emission is binned to a HEALPix map with resolution given by\n    `nside`.\n\n    Args:\n        freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n            a bandpass over which to evaluate the zodiacal emission. The frequencies\n            must be strictly increasing.\n        pixels: HEALPix pixel indicies representing points on the celestial sphere.\n        nside: HEALPix resolution parameter of the pixels and the binned map.\n        obs_time: Time of observation.\n        obs: Name of the Solar System observer. A list of all support observers (for a\n            given ephemeridis) is specified in `supported_observers` attribute of the\n            `Zodipy` instance. Defaults to 'earth'.\n        obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n            Overrides the `obs` argument. Default is None.\n        weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n            are assumed to be given in spectral radiance units (Jy/sr).\n        return_comps: If True, the emission is returned component-wise. Defaults to False.\n        coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n            coordinates) by default.\n\n    Returns:\n        emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n    \"\"\"\n    pixels = get_validated_pix(pixels=pixels, nside=nside)\n\n    unique_pixels, counts = np.unique(pixels, return_counts=True)\n    unit_vectors = get_unit_vectors_from_pixels(\n        coord_in=coord_in,\n        pixels=unique_pixels,\n        nside=nside,\n    )\n\n    return self._compute_emission(\n        freq=freq,\n        weights=weights,\n        obs=obs,\n        obs_time=obs_time,\n        obs_pos=obs_pos,\n        unit_vectors=unit_vectors,\n        indicies=counts,\n        binned=True,\n        pixels=unique_pixels,\n        nside=nside,\n        return_comps=return_comps,\n    )\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.get_emission_ang","title":"<code>get_emission_ang(freq, theta, phi, obs_time, obs='earth', obs_pos=None, weights=None, lonlat=False, return_comps=False, coord_in='E')</code>","text":"<p>Return the simulated zodiacal emission given angles on the sky.</p> <p>The pointing, for which to compute the emission, is specified in form of angles on the sky given by <code>theta</code> and <code>phi</code>.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>FrequencyOrWavelength</code> <p>Delta frequency/wavelength or a sequence of frequencies corresponding to a bandpass over which to evaluate the zodiacal emission. The frequencies must be strictly increasing.</p> required <code>theta</code> <code>SkyAngles</code> <p>Angular co-latitude coordinate of a point, or a sequence of points, on the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either radians or degrees.</p> required <code>phi</code> <code>SkyAngles</code> <p>Angular longitude coordinate of a point, or a sequence of points, on the celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either radians or degrees.</p> required <code>obs_time</code> <code>Time</code> <p>Time of observation.</p> required <code>obs</code> <code>str</code> <p>Name of the Solar System observer. A list of all support observers (for a given ephemeridis) is specified in <code>supported_observers</code> attribute of the <code>Zodipy</code> instance. Defaults to 'earth'.</p> <code>'earth'</code> <code>obs_pos</code> <code>Quantity[AU] | None</code> <p>The heliocentric ecliptic cartesian position of the observer in AU. Overrides the <code>obs</code> argument. Default is None.</p> <code>None</code> <code>weights</code> <code>Sequence[float] | NDArray[floating] | None</code> <p>Bandpass weights corresponding the the frequencies in <code>freq</code>. The weights are assumed to be given in spectral radiance units (Jy/sr).</p> <code>None</code> <code>lonlat</code> <code>bool</code> <p>If True, input angles (<code>theta</code>, <code>phi</code>) are assumed to be longitude and latitude, otherwise, they are co-latitude and longitude.</p> <code>False</code> <code>return_comps</code> <code>bool</code> <p>If True, the emission is returned component-wise. Defaults to False.</p> <code>False</code> <code>coord_in</code> <code>Literal['E', 'G', 'C']</code> <p>Coordinate frame of the input pointing. Assumes 'E' (ecliptic coordinates) by default.</p> <code>'E'</code> <p>Returns:</p> Name Type Description <code>emission</code> <code>Quantity[MJy / sr]</code> <p>Simulated zodiacal emission in units of 'MJy/sr'.</p> Source code in <code>zodipy/zodipy.py</code> <pre><code>def get_emission_ang(\n    self,\n    freq: FrequencyOrWavelength,\n    theta: SkyAngles,\n    phi: SkyAngles,\n    obs_time: Time,\n    obs: str = \"earth\",\n    obs_pos: u.Quantity[u.AU] | None = None,\n    weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n    lonlat: bool = False,\n    return_comps: bool = False,\n    coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated zodiacal emission given angles on the sky.\n\n    The pointing, for which to compute the emission, is specified in form of angles on\n    the sky given by `theta` and `phi`.\n\n    Args:\n        freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n            a bandpass over which to evaluate the zodiacal emission. The frequencies\n            must be strictly increasing.\n        theta: Angular co-latitude coordinate of a point, or a sequence of points, on\n            the celestial sphere. Must be in the range [0, \u03c0] rad. Units must be either\n            radians or degrees.\n        phi: Angular longitude coordinate of a point, or a sequence of points, on the\n            celestial sphere. Must be in the range [0, 2\u03c0] rad. Units must be either\n            radians or degrees.\n        obs_time: Time of observation.\n        obs: Name of the Solar System observer. A list of all support observers (for a\n            given ephemeridis) is specified in `supported_observers` attribute of the\n            `Zodipy` instance. Defaults to 'earth'.\n        obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n            Overrides the `obs` argument. Default is None.\n        weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n            are assumed to be given in spectral radiance units (Jy/sr).\n        lonlat: If True, input angles (`theta`, `phi`) are assumed to be longitude and\n            latitude, otherwise, they are co-latitude and longitude.\n        return_comps: If True, the emission is returned component-wise. Defaults to False.\n        coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n            coordinates) by default.\n\n    Returns:\n        emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n    \"\"\"\n    theta, phi = get_validated_ang(theta=theta, phi=phi, lonlat=lonlat)\n\n    unique_angles, indicies = np.unique(np.asarray([theta, phi]), return_inverse=True, axis=1)\n    unit_vectors = get_unit_vectors_from_ang(\n        coord_in=coord_in,\n        theta=unique_angles[0],\n        phi=unique_angles[1],\n        lonlat=lonlat,\n    )\n\n    return self._compute_emission(\n        freq=freq,\n        weights=weights,\n        obs=obs,\n        obs_time=obs_time,\n        obs_pos=obs_pos,\n        unit_vectors=unit_vectors,\n        indicies=indicies,\n        return_comps=return_comps,\n    )\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.get_emission_pix","title":"<code>get_emission_pix(freq, pixels, nside, obs_time, obs='earth', obs_pos=None, weights=None, return_comps=False, coord_in='E')</code>","text":"<p>Return the simulated zodiacal emission given pixel numbers.</p> <p>The pixel numbers represent the pixel indicies on a HEALPix grid with resolution given by <code>nside</code>.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>FrequencyOrWavelength</code> <p>Delta frequency/wavelength or a sequence of frequencies corresponding to a bandpass over which to evaluate the zodiacal emission. The frequencies must be strictly increasing.</p> required <code>pixels</code> <code>Pixels</code> <p>HEALPix pixel indicies representing points on the celestial sphere.</p> required <code>nside</code> <code>int</code> <p>HEALPix resolution parameter of the pixels and the binned map.</p> required <code>obs_time</code> <code>Time</code> <p>Time of observation.</p> required <code>obs</code> <code>str</code> <p>Name of the Solar System observer. A list of all support observers (for a given ephemeridis) is specified in <code>supported_observers</code> attribute of the <code>Zodipy</code> instance. Defaults to 'earth'.</p> <code>'earth'</code> <code>obs_pos</code> <code>Quantity[AU] | None</code> <p>The heliocentric ecliptic cartesian position of the observer in AU. Overrides the <code>obs</code> argument. Default is None.</p> <code>None</code> <code>weights</code> <code>Sequence[float] | NDArray[floating] | None</code> <p>Bandpass weights corresponding the the frequencies in <code>freq</code>. The weights are assumed to be given in spectral radiance units (Jy/sr).</p> <code>None</code> <code>return_comps</code> <code>bool</code> <p>If True, the emission is returned component-wise. Defaults to False.</p> <code>False</code> <code>coord_in</code> <code>Literal['E', 'G', 'C']</code> <p>Coordinate frame of the input pointing. Assumes 'E' (ecliptic coordinates) by default.</p> <code>'E'</code> <p>Returns:</p> Name Type Description <code>emission</code> <code>Quantity[MJy / sr]</code> <p>Simulated zodiacal emission in units of 'MJy/sr'.</p> Source code in <code>zodipy/zodipy.py</code> <pre><code>def get_emission_pix(\n    self,\n    freq: FrequencyOrWavelength,\n    pixels: Pixels,\n    nside: int,\n    obs_time: Time,\n    obs: str = \"earth\",\n    obs_pos: u.Quantity[u.AU] | None = None,\n    weights: Sequence[float] | npt.NDArray[np.floating] | None = None,\n    return_comps: bool = False,\n    coord_in: Literal[\"E\", \"G\", \"C\"] = \"E\",\n) -&gt; u.Quantity[u.MJy / u.sr]:\n\"\"\"Return the simulated zodiacal emission given pixel numbers.\n\n    The pixel numbers represent the pixel indicies on a HEALPix grid with resolution\n    given by `nside`.\n\n    Args:\n        freq: Delta frequency/wavelength or a sequence of frequencies corresponding to\n            a bandpass over which to evaluate the zodiacal emission. The frequencies\n            must be strictly increasing.\n        pixels: HEALPix pixel indicies representing points on the celestial sphere.\n        nside: HEALPix resolution parameter of the pixels and the binned map.\n        obs_time: Time of observation.\n        obs: Name of the Solar System observer. A list of all support observers (for a\n            given ephemeridis) is specified in `supported_observers` attribute of the\n            `Zodipy` instance. Defaults to 'earth'.\n        obs_pos: The heliocentric ecliptic cartesian position of the observer in AU.\n            Overrides the `obs` argument. Default is None.\n        weights: Bandpass weights corresponding the the frequencies in `freq`. The weights\n            are assumed to be given in spectral radiance units (Jy/sr).\n        return_comps: If True, the emission is returned component-wise. Defaults to False.\n        coord_in: Coordinate frame of the input pointing. Assumes 'E' (ecliptic\n            coordinates) by default.\n\n    Returns:\n        emission: Simulated zodiacal emission in units of 'MJy/sr'.\n\n    \"\"\"\n    pixels = get_validated_pix(pixels=pixels, nside=nside)\n\n    unique_pixels, indicies = np.unique(pixels, return_inverse=True)\n    unit_vectors = get_unit_vectors_from_pixels(\n        coord_in=coord_in,\n        pixels=unique_pixels,\n        nside=nside,\n    )\n\n    return self._compute_emission(\n        freq=freq,\n        weights=weights,\n        obs=obs,\n        obs_time=obs_time,\n        obs_pos=obs_pos,\n        unit_vectors=unit_vectors,\n        indicies=indicies,\n        pixels=unique_pixels,\n        nside=nside,\n        return_comps=return_comps,\n    )\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.get_parameters","title":"<code>get_parameters()</code>","text":"<p>Return a dictionary containing the interplanetary dust model parameters.</p> Source code in <code>zodipy/zodipy.py</code> <pre><code>def get_parameters(self) -&gt; ParameterDict:\n\"\"\"Return a dictionary containing the interplanetary dust model parameters.\"\"\"\n    return self._ipd_model.to_dict()\n</code></pre>"},{"location":"reference/#zodipy.zodipy.Zodipy.update_parameters","title":"<code>update_parameters(parameters)</code>","text":"<p>Update the interplanetary dust model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>ParameterDict</code> <p>Dictionary of parameters to update. The keys must be the names of the parameters as defined in the model. To get the parameters dict of an existing model, use <code>Zodipy(\"dirbe\").get_parameters()</code>.</p> required Source code in <code>zodipy/zodipy.py</code> <pre><code>def update_parameters(self, parameters: ParameterDict) -&gt; None:\n\"\"\"Update the interplanetary dust model parameters.\n\n    Args:\n        parameters: Dictionary of parameters to update. The keys must be the names\n            of the parameters as defined in the model. To get the parameters dict\n            of an existing model, use `Zodipy(\"dirbe\").get_parameters()`.\n\n    \"\"\"\n    _dict = parameters.copy()\n    _dict[\"comps\"] = {}\n    for key, value in parameters.items():\n        if key == \"comps\":\n            for comp_key, comp_value in value.items():\n                _dict[\"comps\"][ComponentLabel(comp_key)] = type(\n                    self._ipd_model.comps[ComponentLabel(comp_key)]\n                )(**comp_value)\n        elif isinstance(value, dict):\n            _dict[key] = {ComponentLabel(k): v for k, v in value.items()}\n\n    self._ipd_model = self._ipd_model.__class__(**_dict)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#timestreams","title":"Timestreams","text":"<p>Below we illustrate how ZodiPy can be used to create timestreams of the zodiacal emission.  Note that since ZodiPy assumes a constant observer position over the input pointing sequence, the output will not be real timestreams, but for small enough time intervals the error is negligible.</p>"},{"location":"usage/#emission-along-a-meridian","title":"Emission along a meridian","text":"<p>In the following example we simulate what an observer on Earth is expected to see on 14 June,  2022 when looking along a meridian (line of constant longitude) at 30 microns, given the  DIRBE interplanetary dust model.</p> <pre><code>import astropy.units as u\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nmodel = Zodipy(\"dirbe\")\n\nlatitudes = np.linspace(-90, 90, 10000) * u.deg\nlongitudes = np.zeros_like(latitudes)\n\nemission = model.get_emission_ang(\n    30 * u.micron,\n    theta=longitudes,\n    phi=latitudes,\n    lonlat=True,\n    obs_time=Time(\"2022-06-14\"),\n    obs=\"earth\",\n)\n\n\nplt.plot(latitudes, emission)\nplt.xlabel(\"Latitude [deg]\")\nplt.ylabel(\"Emission [MJy/sr]\")\nplt.savefig(\"../img/timestream.png\", dpi=300)\nplt.show()\n</code></pre> <p></p> <p>Note</p> <p>ZodiPy assumes a constant observer position over an input pointing sequence. For an observer on Earth,  the true zodiacal emission signal will move along the ecliptic on the sky by roughly one degree each day.  To account for this effect, the full pointing sequence of an experiment should be chunked into small  subsequences with timescales corresponding to at maximum a day.</p>"},{"location":"usage/#healpix-maps","title":"HEALPix maps","text":"<p>Below we illustrate how ZodiPy can be used to create simulated binned HEALPix maps of the zodiacal emission.</p>"},{"location":"usage/#instantaneous-map-in-ecliptic-coordinates","title":"Instantaneous map in ecliptic coordinates","text":"<p>In the following example we make an instantaneous map of of the zodiacal emission at 857 GHz as seen by an observer on earth on 14 June, 2022 given the Planck 2018 interplanetary dust model.</p> <p><pre><code>import astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nmodel = Zodipy(\"planck18\")\nnside = 256\n\nbinned_emission = model.get_binned_emission_pix(\n    857 * u.GHz,\n    pixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2022-06-14\"),\n    obs=\"earth\",\n)\n\nhp.mollview(\n    binned_emission,\n    title=\"Binned zodiacal emission at 857 GHz\",\n    unit=\"MJy/sr\",\n    min=0,\n    max=1,\n    cmap=\"afmhot\",\n)\nplt.savefig(\"../img/binned.png\", dpi=300)\nplt.show()\n</code></pre> Note that the color bar is logarithmic.</p>"},{"location":"usage/#bandpass-integrated-emission","title":"Bandpass integrated emission","text":"<p>Instruments do not typically observe at delta frequencies. Usually, we are more interested in finding out what the emission looks like over some instrument bandpass. ZodiPy will accept a sequence of frequencies to the <code>freq</code> argument in addition to the corresponding bandpass weights to the <code>weights</code> argument and perform bandpass integration.  Note that the bandpass weights must be in spectral radiance units (Jy/sr), even though the weights them self are unitless. A top hat bandpass is assumed if a sequence of frequencies are used without providing weights. <pre><code>import astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nnside = 128\n\ncenter_freq = 800 * u.GHz\nfreqs = np.linspace(750, 850, 11) * u.GHz\nweights = np.array([2, 3, 5, 9, 11, 11.5, 11, 9, 5, 3, 2])\nplt.plot(freqs, weights)\nplt.xlabel(\"Frequency [GHz]\")\nplt.ylabel(\"Weights\")\nplt.savefig(\"../img/bandpass.png\", dpi=300)\n\nmodel = Zodipy(model=\"planck18\")\n\nemission_central_freq = model.get_binned_emission_pix(\n    freq=center_freq,\n    pixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2022-03-10\"),\n    obs=\"SEMB-L2\",\n)\n\nemission_bandpass_integrated = model.get_binned_emission_pix(\nfreq=freqs,\nweights=weights,\npixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2022-03-10\"),\n    obs=\"SEMB-L2\",\n)\n\nhp.mollview(\n    emission_central_freq,\n    title=f\"Center frequency\",\n    unit=\"MJy/sr\",\n    cmap=\"afmhot\",\n    norm=\"log\",\n)\nplt.savefig(\"../img/center_freq.png\", dpi=300)\n\nhp.mollview(\n    emission_bandpass_integrated,\n    title=\"Bandpass integrated\",\n    unit=\"MJy/sr\",\n    cmap=\"afmhot\",\n    norm=\"log\",\n)\nplt.savefig(\"../img/bandpass_integrated.png\", dpi=300)\nplt.show()\n</code></pre> </p>"},{"location":"usage/#solar-cutoff-angle","title":"Solar cutoff angle","text":"<p>Few experiments look directly in towards the Sun. We can initialize <code>Zodipy</code> with the <code>solar_cut</code>  argument to mask all input pointing that looks in towards the sun with an angular distance smaller  than the <code>solar_cut</code> value.</p> <p><pre><code>import astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nmodel = Zodipy(\"dirbe\", solar_cut=60 * u.deg)\nnside = 256\n\nbinned_emission = model.get_binned_emission_pix(\n    25 * u.micron,\n    pixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2020-01-01\"),\n    obs=\"earth\",\n)\n\nhp.mollview(\n    binned_emission,\n    title=\"Solar cutoff at 60 degrees\",\n    unit=\"MJy/sr\",\n    max=80,\n    coord=\"E\",\n    cmap=\"afmhot\",\n)\nplt.savefig(\"../img/binned_solar_cutoff.png\", dpi=300)\nplt.show()\n</code></pre> </p>"},{"location":"usage/#non-ecliptic-coordinates","title":"Non-ecliptic coordinates","text":"<p>We can specify the coordinate system of the input pointing with the <code>coord_in</code> keyword</p> <p><pre><code>import astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nmodel = Zodipy(\"planck18\")\nnside = 256\n\nbinned_emission = model.get_binned_emission_pix(\n    857 * u.GHz,\n    pixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2022-02-20\"),\n    obs=\"earth\",\ncoord_in=\"G\",  # Coordinates of the input pointing\n)\n\nhp.mollview(\n    binned_emission,\n    title=\"Binned zodiacal emission at 857 GHz\",\n    unit=\"MJy/sr\",\n    cmap=\"afmhot\",\n    min=0,\n    max=1,\n)\nplt.savefig(\"../img/binned_gal.png\", dpi=300)\nplt.show()\n</code></pre> </p>"},{"location":"usage/#component-wise-maps","title":"Component-wise maps","text":"<p>ZodiPy can also return the zodiacal emission component-wise. In the following example we use the DIRBE model since the later Planck models excluded the circumsolar-ring and Earth-trailing  feature components. For more information on the interplanetary dust models, please  read Cosmoglobe: Simulating Zodiacal Emission with ZodiPy.</p> <p><pre><code>import astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nmodel = Zodipy(\"dirbe\")\nnside = 256\n\nbinned_emission = model.get_binned_emission_pix(\n    25 * u.micron,\n    pixels=np.arange(hp.nside2npix(nside)),\n    nside=nside,\n    obs_time=Time(\"2022-01-01\"),\n    obs=\"earth\",\nreturn_comps=True,\n)\nfig = plt.figure(figsize=(8, 6.5), constrained_layout=True)\ncomps = [\"Cloud\", \"Band1\", \"Band2\", \"Band3\", \"Ring\", \"Feature\"]\nfor idx, binned_comp_emission in enumerate(binned_emission):\n    hp.mollview(\n        binned_comp_emission,\n        title=comps[idx],\n        norm=\"log\" if idx == 0 else None,\n        cmap=\"afmhot\",\n        cbar=False,\n        sub=(3, 2, idx + 1),\n        fig=fig,\n    )\n# plt.savefig(\"../img/binned_comp.png\", dpi=300)\nplt.show()\n</code></pre> Note that the color for the Cloud component is logarithmic, while the others are linear.</p>"},{"location":"usage/#parallelization","title":"Parallelization","text":"<p>If you are not using ZodiPy in an already parallelized environment, you may specify the number of cores used by ZodiPy through the <code>n_proc</code> keyword. By default <code>n_proc</code> is set to 1. For values of <code>n_proc</code> &gt; 1, the line-of-sight calculations are parallelized using the <code>multiprocessing</code> module.</p> <pre><code>import time\n\nimport astropy.units as u\nimport healpy as hp\nimport numpy as np\nfrom astropy.time import Time\n\nfrom zodipy import Zodipy\n\nnside = 256\npixels = np.arange(hp.nside2npix(nside))\nobs_time = Time(\"2020-01-01\")\nn_proc = 8\n\nmodel = Zodipy()\nmodel_parallel = Zodipy(n_proc=n_proc)\nstart = time.perf_counter()\nemission = model.get_binned_emission_pix(\n    40 * u.micron,\n    pixels=pixels,\n    nside=nside,\n    obs_time=obs_time,\n)\nprint(\"Time spent on a single CPU:\", round(time.perf_counter() - start, 2), \"seconds\")\n# &gt; Time spent on a single CPU: 35.23 seconds\n\nstart = time.perf_counter()\nemission_parallel = model_parallel.get_binned_emission_pix(\n    40 * u.micron,\n    pixels=pixels,\n    nside=nside,\n    obs_time=obs_time,\n)\nprint(\n    f\"Time spent on {n_proc} CPUs:\",\n    round(time.perf_counter() - start, 2),\n    \"seconds\",\n)\n# &gt; Time spent on 8 CPUs: 12.85 seconds\n\nassert np.allclose(emission, emission_parallel)\n</code></pre> <p>Windows users</p> <p>Windows users must make sure to wrap the <code>get_*_emission_*</code> function calls in a <code>if __name__ == \"__main__\"</code> guard to avoid spawning infinite processes:  <pre><code>...\nif __name__ == \"__main__\":\n    emission = model.get_emission_pix(\n        ...\n    )\n</code></pre></p> <p>Using ZodiPy in parallelized environments</p> <p>If ZodiPy is used in a parallelized environment one may have to specifically set the environment variable  <code>OMP_NUM_THREADS=1</code> to avoid oversubscription. This is due automatic parallelization in third party libraries such as <code>healpy</code> where for instance the <code>hp.Rotator</code> object automatically parallelizes rotation of unit vectors. This means that when using ZodiPy with pointing in a coordinate system other than ecliptic, even if <code>Zodipy</code> is initialized with <code>n_proc</code>=1, <code>healpy</code> will under the hood automatically distribute the pointing to available CPU's.</p>"},{"location":"usage/#visualizing-the-interplanetary-dust-distribution-of-a-model","title":"Visualizing the interplanetary dust distribution of a model","text":"<p>It is possible to visualize the three-dimensional interplanetary dust distribution of the models used in ZodiPy by using the <code>tabulate_density</code> function which takes in a interplanetary dust model and a custom grid.</p> <p>In the following example we tabulate the density distribution of the DIRBE interplanetary dust model and plot the cross section of the diffuse cloud components density in the yz-plane.</p> <p><pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import LogNorm\n\nfrom zodipy import tabulate_density\n\nN = 200\n\nx = np.linspace(-5, 5, N)  # x-plane\ny = np.linspace(-5, 5, N)  # y-plane\nz = np.linspace(-2, 2, N)  # z-plane\n\ngrid = np.asarray(np.meshgrid(x, y, z))\ndensity_grid = tabulate_density(grid, model=\"dirbe\")\ndensity_grid = density_grid.sum(axis=0)  # Sum over all components\n\nplt.pcolormesh(\n    x,\n    y,\n    density_grid[N // 2].T,  # cross section in the yz-plane\n    cmap=\"afmhot\",\n    norm=LogNorm(vmin=density_grid.min(), vmax=density_grid.max()),\n    shading=\"gouraud\",\n    rasterized=True,\n)\nplt.title(\"Cross section of the interplanetary dust density (yz-plane)\")\nplt.xlabel(\"x [AU]\")\nplt.ylabel(\"z [AU]\")\n# plt.savefig(\"../img/density_grid.png\", dpi=300)\nplt.show()\n</code></pre> </p>"}]}